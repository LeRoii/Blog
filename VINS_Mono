Eigen::Quaternion::inversse():
return the quaternion describing the inverse rotation






Estimator:

Vector3d Ps[(WINDOW_SIZE + 1)]:
Position

Vector3d Vs[(WINDOW_SIZE + 1)]:
Velocity

Matrix3d Rs[(WINDOW_SIZE + 1)]:
Rotation

Vector3d Bas[(WINDOW_SIZE + 1)]:
accelerometer Bias,对应linear_acceleration在x,y,z的bias
   
Vector3d Bgs[(WINDOW_SIZE + 1)]:
gyroscope Bias,对应angular velocity在x,y,z的bias

vector<double> dt_buf[(WINDOW_SIZE + 1)]：
time interval between two frames

vector<Vector3d> linear_acceleration_buf[(WINDOW_SIZE + 1)]:
linear_acceleration

vector<Vector3d> angular_velocity_buf[(WINDOW_SIZE + 1)]:
angular velocity

IntegrationBase *pre_integrations[(WINDOW_SIZE + 1)]:
integration for every frame in slide window

Vector3d acc_0:
raw linear_acceleration measurment IMU加速度观测值

Vector3d gry_0:
raw angular velocity measurment 角速度观测值

Matrix3d ric[NUM_OF_CAM]:


Vector3d tic[NUM_OF_CAM]:


estimator_node.cpp:

Eigen::Quaterniond tmp_Q:
temporal quaternion???

Eigen::Vector3d tmp_Ba:
linear_acceleration bias

Eigen::Vector3d tmp_Bg:
angular velocity bias

Eigen::Vector3d acc_0：
linear_acceleration上一帧的观测值

Eigen::Vector3d gyr_0：
angular velocity上一帧的观测值

void predict(const sensor_msgs::ImuConstPtr &imu_msg):

```cpp
Eigen::Vector3d un_acc_0 = tmp_Q * (acc_0 - tmp_Ba - tmp_Q.inverse() * estimator.g);
```
acc_0-bias-重力加速度g得到真实值，结果和tmp_Q相乘，得到一个旋转后的向量，旋转轴和角度由tmp_Q给出

Eigen::Vector3d un_acc_0：
？？？？？

```cpp
Eigen::Vector3d un_gyr = 0.5 * (gyr_0 + angular_velocity) - tmp_Bg;
```
gyr_0和angular_velocity求平均？？？然后减去Bias

Eigen::Vector3d un_gyr:
angular_velocity真实值？？？

```cpp
tmp_Q = tmp_Q * Utility::deltaQ(un_gyr * dt);
```
两帧之间旋转的变化量(un_gyr * dt)，除2，用quaternion表示，实部为1，赋给tmp_Q

```cpp
Eigen::Vector3d un_acc_1 = tmp_Q * (linear_acceleration - tmp_Ba - tmp_Q.inverse() * estimator.g);
```
linear_acceleration测量值减bias，减重力加速度，乘tmp_Q（考虑两帧间发生的旋转）

Eigen::Vector3d un_acc_1：
linear_acceleration真实值？？？？

```cpp
Eigen::Vector3d un_acc = 0.5 * (un_acc_0 + un_acc_1);
```
un_acc_0和un_acc_1取平均得到最后的真实值？？？

```cpp
tmp_P = tmp_P + dt * tmp_V + 0.5 * dt * dt * un_acc;
tmp_V = tmp_V + dt * un_acc;
```
由刚得到的加速度更新位置和速度

```
acc_0 = linear_acceleration;
gyr_0 = angular_velocity;
```
更新观测值？？？？